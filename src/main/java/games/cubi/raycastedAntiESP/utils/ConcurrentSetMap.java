package games.cubi.raycastedAntiESP.utils;

import org.jetbrains.annotations.NotNull;

import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

// A map-like class, methods were generated by implementing all required methods of the Map interface, however implementation of Map is now removed to prevent any side effects from using default methods which have not been vetted (ex. if computeIfAbsent was not overridden, and Map was implemented, it would be possible to add a non-concurrent Set to the map.)

/**
 * A map-like class which maps keys to sets of values. Keys and value sets are all guaranteed to be thread safe, as they are backed by a ConcurrentHashMap and concurrent sets created by ConcurrentHashMap.newKeySet(). No care needs to be taken to ensure that concurrent Sets are passed in, as all sets are replaced by concurrent sets when added to the map. This has the side effect of making it so that the sets returned by the map are not the same sets that were put in, but they will be concurrent and contain the same values.
 * @param <K> The type of keys maintained by this map
 * @param <V> The type of values maintained by the sets in this map
 */
public class ConcurrentSetMap<K, V>  {
    private final ConcurrentHashMap<K, Set<V>> backingMap;

    public ConcurrentSetMap() {
        this.backingMap = new ConcurrentHashMap<>();
    }

    public ConcurrentSetMap(int initialCapacity) {
        this.backingMap = new ConcurrentHashMap<>(initialCapacity);
    }

    /**
     * Using this is <strong>NOT</strong> recommended, as it allows for creation of keys not associated with concurrent sets. Wherever possible, use the methods provided by ConcurrentSetMap to ensure that all sets are concurrent and thread safe. This is only provided for cases where you need to perform operations on the backing map that are not exposed by ConcurrentSetMap, but you should be careful when doing so.
     * @return The actual backing ConcurrentHashMap. Any modifications to this map will affect the ConcurrentSetMap, and vice versa. This is not a copy.
     */
    public ConcurrentHashMap<K, Set<V>> asActualConcurrentMap() {
        return backingMap;
    }

    /**
     * Adds a single value to the set associated with the key.
     * Creates a concurrent set if absent.
     */
    public boolean add(K key, V value) {
        return backingMap
                .computeIfAbsent(key, k -> newConcurrentSet())
                .add(value);
    }

    /**
     * Removes a single value from the set associated with the key.
     */
    public boolean removeValue(K key, V value) {
        Set<V> set = backingMap.get(key);
        if (set == null) {
            return false;
        }

        boolean removed = set.remove(value);

        if (set.isEmpty()) {
            backingMap.remove(key);
        }

        return removed;
    }

    //@Override
    public int size() {
        return backingMap.size();
    }

    //@Override
    public boolean isEmpty() {
        return backingMap.isEmpty();
    }

    //@Override
    public boolean containsKey(K key) {
        return backingMap.containsKey(key);
    }

    //@Override

    /**
     * @param value The value to check for in the sets.
     * @return True if any of the sets in the map contain the value, false otherwise.
     */
    public boolean containsValue(V value) {
        return backingMap.values().stream().anyMatch(set -> set.contains(value));
    }

    public boolean containsValue(Set<V> value) {
        return backingMap.containsValue(value);
    }

    //@Override
    public Set<V> get(K key) {
        return backingMap.get(key);
    }

    public Set<V> getOrDefault(K key, Set<V> of) {
        return backingMap.getOrDefault(key, of);
    }

    //@Override
    @SuppressWarnings("UnusedReturnValue")
    public Set<V> put(K key, Set<V> values) {
        Set<V> concurrentSet = newConcurrentSet(values);
        return backingMap.put(key, concurrentSet);
    }

    //@Override
    public Set<V> remove(K key) {
        return backingMap.remove(key);
    }

    //@Override
    public void putAll(@NotNull Map<? extends K, ? extends Set<V>> m) {
        m.forEach(this::put);
    }

    //@Override
    public void clear() {
        backingMap.clear();
    }

    //@Override
    public @NotNull Set<K> keySet() {
        return backingMap.keySet();
    }

    //@Override
    public @NotNull Collection<Set<V>> values() {
        return backingMap.values();
    }

    //@Override
    public @NotNull Set<Map.Entry<K, Set<V>>> entrySet() {
        return backingMap.entrySet();
    }

    //@Override
    public Set<V> computeIfAbsent(K key, @NotNull Function<? super K, ? extends Set<V>> mappingFunction) {

        return backingMap.computeIfAbsent(key, k -> {
            Set<V> produced = mappingFunction.apply(k);
            return newConcurrentSet(produced);
        });
    }


    private Set<V> newConcurrentSet() {
        return ConcurrentHashMap.newKeySet();
    }

    private Set<V> newConcurrentSet(Set<V> values) {
        Set<V> set = ConcurrentHashMap.newKeySet();
        set.addAll(values);
        return set;
    }
}
